# Technical Documentation Requirement Template

## Purpose
- Provide a repeatable set of instructions for drafting module-level technical documentation that mirrors the structure and depth of `REQ001.md`.
- Enable an LLM author (writer) and an implementation agent (executor) to collaborate efficiently by sharing a consistent outline, evidence expectations, and formatting rules.

## Roles & Responsibilities
- **Writer (LLM):** Assembles the documentation by transforming verified project facts into prose that follows this template.
- **Executor (Agent):** Supplies the writer with requested data (file listings, code snippets, metrics) and validates any inferred details.
- Both roles must record every assumption, cite the file path and start line for source facts, and flag any missing information.

## High-Level Workflow
1. **Scoping:** Confirm the module name, primary purpose, and codebase root.
2. **Inventory:** Gather directory trees, file sizes, line counts, and key entry points.
3. **Analysis:** Extract architectural patterns, platform requirements, error handling, and testing approach.
4. **Synthesis:** Populate each section below using concise, evidence-backed statements.
5. **Review:** Ensure every claim maps to a discoverable artefact; request clarification for gaps.

## Document Layout
Follow the exact heading order and casing. Use Markdown anchors in the Table of Contents so section titles auto-link.

### 1. Title Block
- Format: `# <Module Name> - Technical Documentation`.
- Leave one blank line before the Table of Contents.

### 2. Table of Contents
- Heading: `## Table of Contents`.
- Provide a numbered list of section links in document order, e.g. `1. [Overview](#overview)`.

### 3. Overview
- Summarise the module’s purpose, primary consumers, and standout capabilities (3–6 bullet points).
- Call out noteworthy constraints such as required services, authentication modes, or supported platforms.

### 4. Source Code Structure
- Include a code block containing the directory tree rooted at the module entry directory (`tree -I 'node_modules'` or equivalent).
- For each significant file:
  - Use the heading style `#### **relative/path/to/file** (X lines)`.
  - Provide the canonical path reference `Location: \`relative/path:1\``.
  - Describe the file’s purpose in one sentence followed by subsections for key components, patterns, and usage examples.
  - Highlight exported classes/functions and any dependency injection or extension points.
  - Cite representative code snippets inside fenced code blocks.

### 5. Test Coverage
- Report total line count and test-to-source ratio if known.
- Summarise test organisation (unit/integration/e2e) and mention notable fixtures, mocks, or helpers.
- Note any critical gaps or TODOs discovered during analysis.

### 6. Health Check Server
- Document whether a health check or status endpoint exists.
- Include host/port defaults, request/response formats, and monitoring hooks.
- If absent, explicitly state “No health check server is implemented” and describe recommended follow-up.

### 7. Main Entry Point
- Identify the primary executable or bootstrap file (CLI command, SDK entry, HTTP handler, etc.).
- Outline initialisation steps, configuration inputs, and dependency wiring.
- Mention environment variables, configuration files, or required credentials.

### 8. Architecture
- Describe layered structure (CLI/SDK/service, adapters, domain layers).
- Enumerate major patterns (e.g., validation-first, progressive enhancement, observers).
- Capture cross-cutting concerns: logging, caching, rate limiting, error hierarchy.
- Include diagrams or ASCII sketches only when they materially clarify interactions.

### 9. Summary
- Provide a bullet list of key strengths (✓ badges) and open risks (⚠ markers).
- Recap testing confidence.
- Mention external dependencies, version requirements, and integration considerations.

## Writing Standards
- Favour crisp sentences and bullets over long paragraphs.
- Use present tense and active voice.
- Quote identifiers, environment variables, and commands with backticks.
- Keep code blocks minimal and focused on illustrating patterns.
- Cross-reference facts with `path/to/file:line` format.

## Evidence Collection Checklist
- Directory tree with file counts.
- Line counts per key file (`wc -l <file>`).
- Important function/class signatures.
- Configuration files and environment variables.
- Test suite structure and representative cases.
- Error classes and handling flows.

## Validation Requirements
- Every numbered section must contain content; if unavailable, state the gap and the action needed to close it.
- Verify all paths exist at the documented locations.
- Confirm code samples compile or parse in their native language.
- Ensure metrics (line counts, ratios) reflect the latest repository state.

## Deliverable Acceptance Criteria
- Markdown file mirrors this template ordering and formatting.
- All claims reference verifiable artefacts.
- No placeholder text remains (replace `<Module Name>` and similar tokens).
- Document stays within ASCII and renders correctly in GitHub-flavoured Markdown.
- Final draft reviewed by both writer and executor for accuracy and completeness.
